/*
 * Copyright (c) 2000 by SAP AG, Walldorf.,
 * http://www.sap.com
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of SAP AG, Walldorf. You shall not disclose such Confidential
 * Information and shall use it only in accordance with the terms
 * of the license agreement you entered into with SAP.
 */
package com.sap.engine.services.servlets_jsp.jspparser_api.jspparser;

/*
 *
 * @author Galin Galchev
 * @version 4.0
 */
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;

import javax.servlet.jsp.tagext.TagLibraryInfo;
import javax.servlet.jsp.tagext.TagLibraryValidator;
import javax.servlet.jsp.tagext.ValidationMessage;

import com.sap.engine.lib.descriptors5.javaee.ParamValueType;
import com.sap.engine.lib.descriptors5.webjsptld.ValidatorType;
import com.sap.engine.lib.util.ConcurrentHashMapObjectObject;
import com.sap.engine.services.servlets_jsp.jspparser_api.ComponentDecorator;
import com.sap.engine.services.servlets_jsp.jspparser_api.JspPageInterface;
import com.sap.engine.services.servlets_jsp.jspparser_api.exception.JspParseException;
import com.sap.engine.services.servlets_jsp.jspparser_api.jspparser.syntax.PageDataImpl;
import com.sap.engine.services.servlets_jsp.jspparser_api.jspparser.taglib.TagLibUtil;
import com.sap.engine.services.servlets_jsp.server.LogContext;
import com.sap.engine.services.servlets_jsp.server.deploy.descriptor.TagLibDescriptor;
import com.sap.tc.logging.Location;

/**
 * This class generates a java file representing the functionality of the jsp. It uses source
 * for this file generated by JspParser class which translates a jsp page.
 */
public class GenerateJavaFile {  
  private ClassLoader inThreadLoader = null;
  private JspPageInterface parser = null;

  private PrintWriter out = null;


  public GenerateJavaFile(PrintWriter out){
    this.out = out;

  }

	/**
	 * Parses JSP file to StringBufferes,
	 * makes callback to the Parsable parameter
	 * writes the composed java file to the output
	 * @param callBack
	 * @param parser
	 * @throws JspParseException
	 */
  public void generateJavaFile(ComponentDecorator callBack, JspPageInterface parser
      )throws JspParseException {

	  this.parser = parser;
		Thread currentThread = Thread.currentThread();
		inThreadLoader = currentThread.getContextClassLoader();
		currentThread.setContextClassLoader(parser.getWebContainerParameters().getServiceClassLoader());
		try {
		  parser.parse().action();
		} finally {
		  currentThread.setContextClassLoader(inThreadLoader);
		}
		if ( parser.getTagLibraryValidators()!= null && parser.getTagLibraryValidators().size() > 0)
		{
			validate(parser.getWebContainerParameters().getServiceClassLoader());
		}
	  callBack.decorate(parser);
    writeToStream(out, parser);
  }

  public void generateJavaFile(String className, ComponentDecorator callback, JspPageInterface parser)
      throws JspParseException, JspParseException {
		this.parser = parser;
    parser.setPageClassname(className);
    parser.parse().action();
    callback.decorate(parser);
    writeToStream(out, parser);
  }

  private void validate(ClassLoader threadLoader)
      throws JspParseException {
    //validate
    if (parser != null && parser.getTaglibs().size() > 0) {
      PageDataImpl pageData = new PageDataImpl(parser.getParsed(), parser.isXml(), parser.getJspProperty().isOldApplication());
      Thread.currentThread().setContextClassLoader(threadLoader);
      try {
        validate(pageData, (LifoDuplicateMap<String, TagLibraryInfo>)parser.getTaglibs(), parser.getTagLibraryValidators(), parser.getApplicationClassLoader());
      } finally {
        Thread.currentThread().setContextClassLoader(inThreadLoader);
      }
    }
  }

  // ------------------------------ PRIVATE ------------------------------
  
  public static void validate(PageDataImpl page, LifoDuplicateMap<String, TagLibraryInfo> tagLibsInPage , ConcurrentHashMapObjectObject validators, ClassLoader applicationClassLoader) throws JspParseException {
    // each taglib should be validated only once
    // keep track of already validated ones and do not call validate() on them
    List<String> validated = new ArrayList<String>();

    // iterate over the prefixes, because if one taglib is used more than once
    // with different prefixes, they share the same TagLibDescriptor
    // Hence, the tld.getPrefix() is bogus
    TagLibraryInfo[] tlds =  TagLibUtil.getUniqueTaglibs(tagLibsInPage);
    for (TagLibraryInfo tld : tlds) {
      TagLibDescriptor tli = (TagLibDescriptor)tld;
      // skip if already validated
      if (validated.contains(tli.getURI())) {
        continue;
      }
      TagLibraryValidator tlv = null;
      // tli.getTagLibrary().getUri() - contains the URI from the TLD
      // tli.getURI() - is the URI from the taglib directive in the JSP
      if( tli.getURI() != null ) { // instantiated during ApplicationThreadInitializer
        if( validators != null ) {
          tlv = (TagLibraryValidator) validators.get(tli.getURI());
        }
      } else { // no URI available for the mapping in the validators hasmap, therefore instantiate them on demand
        if( tli.getTagLibrary().getValidator() != null ) {
          tlv = instantiateValidator(applicationClassLoader, tli);
        }
      }
      
      if (tlv == null) {
        continue;
      }
      // init parameters should be set each time validator is used because tlv.release() sets them to null.
      HashMap<String, Object> paramsTempMap = new HashMap<String, Object>();
      ParamValueType[] paramsTemp = tli.getTagLibrary().getValidator().getInitParam();
      if (paramsTemp != null) {
        for (int i = 0; i < paramsTemp.length; i++) {
          paramsTempMap.put(paramsTemp[i].getParamName().get_value(), paramsTemp[i].getParamValue().get_value());
        }
      }
      tlv.setInitParameters(paramsTempMap);
      page.generateXMLView();
      ValidationMessage[] errors = null;
      if( tli.getURI() != null ) {
        errors = tlv.validate(tli.getPrefixString(), tli.getURI(), page);  
      } else {
        errors = tlv.validate(tli.getPrefixString(), tli.getTagLibrary().getUri().get_value().toString(), page);  
      }
      
      tlv.release();
      if ((errors != null) && (errors.length != 0)) {
        String msg = "\n\t";
        for (int i = 0; i < errors.length; i++) {
          msg = msg + errors[i].getMessage() + "\n\t";
        }
        throw new JspParseException(JspParseException.TAGLIBVALIDATOR_RETURN_ERRORS_FOR_TAGLIB, new Object[]{tli.getURI(), msg});
      }
      validated.add(tli.getURI());
    }
  }
	
  /**
   * Instantiates a class for the validator of this TLD. 
   * @param applicationClassloader - the applciation Classsloader from which the validator class is loaded
   * @param tld - The tag library descriptor. 
   * @return null if no TLV is found in this TLD or instance of the tag library validator for the given TLD.
   */
  public static TagLibraryValidator instantiateValidator(ClassLoader applicationClassloader, TagLibDescriptor tld ) {
    ValidatorType validatorDesc = tld.getTagLibrary().getValidator();
    if (validatorDesc != null && validatorDesc.getValidatorClass() != null) {
      try {
        Class validatorClass = applicationClassloader.loadClass(validatorDesc.getValidatorClass().get_value());
        TagLibraryValidator tlv = (TagLibraryValidator) validatorClass.newInstance();
        return tlv;
      } catch (OutOfMemoryError e) {
        throw e;
      } catch (ThreadDeath e) {
        throw e;
      } catch (Throwable e) {
        LogContext.getCategory(LogContext.CATEGORY_DEPLOY).logError(Location.getLocation(GenerateJavaFile.class), "ASJ.web.000254", 
          "Cannot initialize taglib validator [{0}].", new Object[]{validatorDesc.getValidatorClass()}, e, null, null);       
      }
    }
    return null;
  }

  private void writeToStream( PrintWriter out, JspPageInterface parser) {
  	
    try {
      // generate header and start of class
      out.println(parser.getCommentCode());
      
	  	String className = parser.getPageClassname();
      if (parser.getPageClassname().indexOf('.') > 0){
        out.println("package " + parser.getPageClassname().substring(0, parser.getPageClassname().lastIndexOf('.')) + ";");
        className = parser.getPageClassname().substring(parser.getPageClassname().lastIndexOf('.') + 1);
      }
      out.println(parser.getImportDirective());
      out.print("public class " + className);

			
			if ( parser.getExtendsDirective().length() > 0 )
			{
      	out.print(" extends " + parser.getExtendsDirective());
			}
      	
      if (parser.getImplemetsDirective().length() != 0) {
        out.print(" implements " + parser.getImplemetsDirective());
      }

      out.println("{");
      // generate declarations
      out.println(parser.getDeclarationsCode());
			//STATIC
			out.println(parser.getClassBodyCode());
			
			//generateServiceMethod(out, parser);

      if (parser.getServletInfo() != null) {
        out.println("\tpublic String getServletInfo() {");
        out.println("\t\treturn \"" + parser.getServletInfo() + "\";\n");
        out.println("\t}");
      }
       //adds generated tag's methods
      Enumeration  tagMethods = parser.getTagMethodsCode().elements();
      while (tagMethods.hasMoreElements()) {
        out.println("\r\n" + (StringBuffer)tagMethods.nextElement());
      }

      //adds generated jsp:attribute's methods
//      Enumeration  attrMethods = parser.getJspAttributesCode().keys();
//      while (attrMethods.hasMoreElements()) {
//        out.println("\r\n\t" + (String)parser.getJspAttributesCode().get((String)attrMethods.nextElement()));
//      }

      //adds generated jsp:body's methods
//      Enumeration  bodyMethods = parser.getJspBodyCode().keys();
//      while (bodyMethods.hasMoreElements()) {
//        out.println("\r\n\t" + (String)parser.getJspBodyCode().get((String)bodyMethods.nextElement()));
//      }

      if (!parser.getTagFragmentMethodsCode().isEmpty()) {
        Enumeration tagFragmentMethods = parser.getTagFragmentMethodsCode().elements();
        int methodsCount = 0;

        out.println("\tprivate class " + className + "_Helper");
        out.println("\t\textends com.sap.engine.services.servlets_jsp.lib.jspruntime.JspFragmentBase");
        out.println("\t{");
        out.println("\t\tprivate javax.servlet.jsp.tagext.JspTag _jspx_parent;");
        out.println("\t\tprivate int[] _jspx_push_body_count;");

        out.println("");
        out.println("\t\tpublic " + className + "_Helper(int index, JspContext jspContext, javax.servlet.jsp.tagext.JspTag _jspx_parent, int[] _jspx_push_body_count)");
        out.println("\t\t{");
        out.println("\t\t\tsuper(index, jspContext, _jspx_parent);");
        out.println("\t\t\tthis._jspx_parent = _jspx_parent;");
        out.println("\t\t\tthis._jspx_push_body_count = _jspx_push_body_count;");
        out.println("\t\t}");

        while (tagFragmentMethods.hasMoreElements()) {
          out.println((StringBuffer)tagFragmentMethods.nextElement());
          methodsCount++;
        }

        out.println("\t\tpublic void invoke(java.io.Writer writer)");
        out.println("\t\t\tthrows JspException");
        out.println("\t\t{");
        out.println("\t\t\tJspWriter out = null;");
        out.println("\t\t\tif (writer != null) {");
        out.println("\t\t\t\tout = this.jspContext.pushBody(writer);");
        out.println("\t\t\t} else {");
        out.println("\t\t\t\tout = this.jspContext.getOut();");
        out.println("\t\t\t}");
        out.println("\t\t\ttry {");
        out.println("\t\t\t\tswitch(this.index) {");
        for (int i = 0; i < methodsCount; i++) {
          out.println("\t\t\t\tcase " + i + ":");
          out.println("\t\t\t\t\tinvoke" + i + "(out);");
          out.println("\t\t\t\t\tbreak;");
        }
        out.println("\t\t\t\t}");
        out.println("\t\t\t} catch(Throwable e) {");
        out.println("\t\t\t\tif (e instanceof SkipPageException)");
        out.println("\t\t\t\t\tthrow (SkipPageException) e;");
        out.println("\t\t\t\tthrow new JspException(e);");
        out.println("\t\t\t} finally {");
        out.println("\t\t\t\tif (writer != null) {");
        out.println("\t\t\t\t\tthis.jspContext.popBody();");
        out.println("\t\t\t\t}");
        out.println("\t\t\t}");
        out.println("\t\t}");   //close invoke
        out.println("\t}");     //close class
      }

      // generate end of class
      out.println("}");
    } finally {
      out.close();
    }
  }
}

