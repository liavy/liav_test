package com.sap.engine.frame.core.thread;

import java.io.UnsupportedEncodingException;
import java.util.Random;

import com.sap.engine.system.ThreadWrapper;
import com.sap.engine.system.ThreadWrapperExt;
import com.sap.tc.logging.Location;
import com.sap.tc.logging.Severity;
import com.sap.engine.core.Names;


public class ClientIDPropagator implements ContextObject, TransferableExt {

	private static Location location;
	static {
		try {
			location = Location.getLocation(ClientIDPropagator.class.getName(), Names.KERNEL_DC_NAME, Names.THREAD_MANAGER_CSN_COMPONENT);
		} catch (Throwable t) {
		  //$JL-EXC$ NosuchMethodError can be thrown here in case of remote classloading on client side because this method does not exist on old versions.
			location = Location.getLocation(ClientIDPropagator.class);
		}
	}
	
	
	/** The name of the context object with which it is registered in ThreadContext */
	public static final String PROPAGATOR_CONTEXT_OBJECT_NAME = "ClientIDPropagator";
	
	/** Encoding used in transaction ID serialization and deserialization */
	private final static String TrID_ENCODING = "UTF-8";
	
	/** The side of the transaction ID in byte[] form */
	private static final int TrID_SIZE = 32;
	
	/** Transaction ID for the current thread in client side. */
	private String transactionID;
	
	/** Flag showing if this context object generates the transaction Id itself or gets it from threading framework */
	private boolean amIGenerator = false;
	
	public ClientIDPropagator () {
	  // never put logging here; it will lead to stackOverFlowError because logging framework uses this method to get transaction ID
	}

	public ClientIDPropagator (String trnasactionId, boolean IAmIdGenerator) {
	  // never put logging here; it will lead to stackOverFlowError because logging framework uses this method to get transaction ID
		this.transactionID = trnasactionId;
		this.amIGenerator = IAmIdGenerator;
	}
		  
	public void load(Object clusterid, byte[] from, int offset) {
		if (location.bePath()) {
		  location.pathT("ClientIDPropagator.load() is called on stub side => transaction ID won't be loaded. Parameters: clusterID = " + clusterid + " from[] = " + new String(from, offset) + " offset = " + offset);
		}
	}

	public int size(Object clusterid) {
		if (location.bePath()) {
		  location.pathT("ClientIDPropagator.size("+clusterid+") is called, returned value is " + TrID_SIZE);
		}
		return TrID_SIZE;		
	}

	public void store(Object clusterid, byte[] to, int offset) {
		try {
			if (location.bePath()) {
			  location.pathT("ClientIDPropagator.store("+clusterid+") is called with parameters: to[] = " + new String(to, offset) + " offset = " + offset);
			}
			if (ThreadWrapper.isthreadMonitoringEnabled()) {
				if ((transactionID = ThreadWrapper.getTransactionId()) == null || amIGenerator) {
					// client side, no transaction ID is available at the moment => generate it
					// or the current ID is generated by this context object instance => regenerate it
					transactionID = generateTransactionID();
					
					if (location.bePath()) {
					  location.pathT("ClientIDPropagator.store("+clusterid+") generated id = " + transactionID);
					}
					
					ThreadWrapperExt.setTransactionId(transactionID);
					amIGenerator = true;
				}
				
				try {
					if (location.bePath()) {
					  location.pathT("ClientIDPropagator.store("+clusterid+") will transfer transaction ID = " + transactionID);
					}
					System.arraycopy(transactionID.getBytes(TrID_ENCODING), 0, to, offset, TrID_SIZE);
				} catch (UnsupportedEncodingException e) {
					if (location.bePath()) {
					  location.traceThrowableT(Severity.PATH, "UnsupportedEncodingException was thrown by String.getBytes("+TrID_ENCODING+") method invocation. Exception was caught and ignored.", e);
					}
				}
			}
		} catch (ThreadDeath td) {
			throw td;
		} catch (OutOfMemoryError oom) {
			throw oom;
		} catch (Throwable e) {
			if (location.bePath()) {
			  location.traceThrowableT(Severity.PATH, "Exception/Error was thrown by ClientIDPropagator.store() method. Exception/Error was caught and ignored.", e);
			}
		}
	}

	public void load(byte[] from, int offset) {
		try {
			if (ThreadWrapper.isthreadMonitoringEnabled()) {
				if (location.bePath()) {
				  location.pathT("ClientIDPropagator.load() is called on skeleton side with parameters: from[] = " + new String(from, offset, TrID_SIZE) + " offset = " + offset);
				}
				// load the transaction id in the current thread on skeleton side.
				boolean amIGenerator_temp = this.amIGenerator;
				ThreadWrapperExt.setTransactionId(new String(from, offset, TrID_SIZE));
				this.amIGenerator = amIGenerator_temp;
			}
		} catch (ThreadDeath td) {
			throw td;
		} catch (OutOfMemoryError oom) {
			throw oom;
		} catch (Throwable e) {
			if (location.bePath()) {
			  location.traceThrowableT(Severity.PATH, "Exception/Error was thrown by ClientIDPropagator.load() method. Exception/Error was caught and ignored.", e);
			}
		}		
	}

	public int size() {
		if (location.bePath()) {
		  location.pathT("ClientIDPropagator.size() is called, returned value is: " + 0);
		}
		return 0;
	}

	public void store(byte[] to, int offset) {
		if (location.bePath()) {
		  location.pathT("ClientIDPropagator.store() is called on skeleton side => transaction ID won't be stored. Parameters: from[] = " + to + " offset = " + offset);
		}
	}

	public ContextObject childValue(ContextObject parent, ContextObject child) {
		if (location.bePath()) {
		  location.pathT("ClientIDPropagator.childValue() is called with parameters: parent = " + parent + " child = " + child + ". Parent " + ((((ClientIDPropagator) parent).amIGenerator)?"is":"is not") + "ID generator, current transaction is is: " + ((ClientIDPropagator) parent).getTransactionId());
		}
		if (parent != null && parent instanceof ClientIDPropagator) {
		  return new ClientIDPropagator(((ClientIDPropagator) parent).getTransactionId(), ((ClientIDPropagator) parent).amIGenerator);
		} else {
			return getInitialValue();
		}
	}
	
	public String getTransactionId() {
		// never put logging here; it will lead to stackOverFlowError because logging framework uses this method to get transaction ID
		return transactionID;
	}
	
	public void setTransactionId(String id) {
		if (location.bePath()) {
		  location.pathT("ClientIDPropagator.setTransactionId() is called with argument " + id);
		}
		transactionID = id;
		amIGenerator = false;
	}

	public void empty() {
		if (location.bePath()) {
		  location.pathT("ClientIDPropagator.empty() is called");
		}
		transactionID = null;	
		amIGenerator = false;
	}

	public ContextObject getInitialValue() {
	  // never put logging here; it will lead to stackOverFlowError because logging framework uses this method to get transaction ID
		return new ClientIDPropagator(null, false);
	}
	
//-------------Generation of transaction ID on client side-----------------------------------------------------------------------------//	
	/** char[] with hex digits used in transformation of transaction ID from char[] to hex String */
	private static final char[] hexDigits =	{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
	
	/** Random number generator used in transaction Id generation*/
  private static Random rand = new Random(System.currentTimeMillis());
  
	private static String generateTransactionID() {
		long ts = System.nanoTime();
		long address = (0x800000000000L | (rand.nextLong() & 0x7fffffffffffL));
    long rephigh = 	(1 << 12 | 								// version
	 			(ts & 0xffffffffL) << 32 | 				// time low
		 			(ts & 0xffff00000000L) >> 16 | 			// time _mid
		 			(ts & 0xfff000000000000L) >> 48); 		// time high

		long replow = 	(0x80L << 56 |							// variant
		 			((long)rand.nextInt(0x4fff)) << 48 |	// clock sequence
					address);
		
		char[] buf = new char[32];
		     
 		int n = (int) (replow & 0xFFFFFFFF);
 		buf[31] = hexDigits[n & 0x0F];
 		buf[30] = hexDigits[(n >>> 4) & 0x0F];
 		buf[29] = hexDigits[(n >>> 8) & 0x0F];
 		buf[28] = hexDigits[(n >>> 12) & 0x0F];
 		buf[27] = hexDigits[(n >>> 16) & 0x0F];
 		buf[26] = hexDigits[(n >>> 20) & 0x0F];
 		buf[25] = hexDigits[(n >>> 24) & 0x0F];
 		buf[24] = hexDigits[(n >>> 28) & 0x0F];
 
 		n = (int) ((replow >>> 32) & 0xFFFFFFFF);
 		buf[23] = hexDigits[n & 0x0F];
 		buf[22] = hexDigits[(n >>> 4) & 0x0F];
 		buf[21] = hexDigits[(n >>> 8) & 0x0F];
 		buf[20] = hexDigits[(n >>> 12) & 0x0F];
 		buf[19] = hexDigits[(n >>> 16) & 0x0F];
 		buf[18] = hexDigits[(n >>> 20) & 0x0F];
 		buf[17] = hexDigits[(n >>> 24) & 0x0F];
 		buf[16] = hexDigits[(n >>> 28) & 0x0F];
 
 		n = (int) (rephigh & 0xFFFFFFFF);
 		buf[15] = hexDigits[n & 0x0F];
 		buf[14] = hexDigits[(n >>> 4) & 0x0F];
 		buf[13] = hexDigits[(n >>> 8) & 0x0F];
 		buf[12] = hexDigits[(n >>> 12) & 0x0F];
 		buf[11] = hexDigits[(n >>> 16) & 0x0F];
 		buf[10] = hexDigits[(n >>> 20) & 0x0F];
 		buf[9] = hexDigits[(n >>> 24) & 0x0F];
 		buf[8] = hexDigits[(n >>> 28) & 0x0F];
 
 		n = (int) ((rephigh >>> 32) & 0xFFFFFFFF);
 		buf[7] = hexDigits[n & 0x0F];
 		buf[6] = hexDigits[(n >>> 4) & 0x0F];
 		buf[5] = hexDigits[(n >>> 8) & 0x0F];
 		buf[4] = hexDigits[(n >>> 12) & 0x0F];
 		buf[3] = hexDigits[(n >>> 16) & 0x0F];
 		buf[2] = hexDigits[(n >>> 20) & 0x0F];
 		buf[1] = hexDigits[(n >>> 24) & 0x0F];
 		buf[0] = hexDigits[(n >>> 28) & 0x0F];
 
 		return new String(buf);
	}

	
}
