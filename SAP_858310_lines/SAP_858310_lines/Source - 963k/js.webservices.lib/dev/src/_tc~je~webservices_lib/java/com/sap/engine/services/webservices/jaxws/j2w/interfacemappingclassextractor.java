/*
 * Copyright (c) 2007 by SAP AG, Walldorf.,
 * http://www.sap.com
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of SAP AG, Walldorf. You shall not disclose such Confidential
 * Information and shall use it only in accordance with the terms
 * of the license agreement you entered into with SAP.
 */
package com.sap.engine.services.webservices.jaxws.j2w;

import java.util.HashSet;
import java.util.Set;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;

import com.sap.engine.services.webservices.espbase.mappings.InterfaceMapping;
import com.sap.engine.services.webservices.espbase.mappings.OperationMapping;
import com.sap.engine.services.webservices.espbase.mappings.ParameterMapping;

/**
 * Javadoc goes here...
 * 
 * Copyright (c) 2007, SAP-AG
 * @author Dimitar Angelov
 * @version 1.0, Jan 15, 2007
 */
public class InterfaceMappingClassExtractor {
  
  private static Class[] loadClasses(String[] classNames, ClassLoader loader) throws ClassNotFoundException {
    if(classNames == null || classNames.length == 0) {
      return new Class[0];  
    }      
    
    Class[] classes = new Class[classNames.length];
    int i = 0;
    for(String className: classNames) {
      classes[i++] = loadClass0(className, loader);   
    }
    
    return classes;
  }
  
  public static Class loadClass0(String clDecl, ClassLoader loader)  throws ClassNotFoundException {
    int ind = clDecl.indexOf(ParameterMapping.JAVA_ARRAY_DIMENSION); //as it is described in the VI.

    if (ind == -1) { //this is not array
      //for simple types
      if (clDecl.equals("byte")) {
        return byte.class; 
      } else if (clDecl.equals("char")) {
        return char.class;
      } else if (clDecl.equals("boolean")) {
        return boolean.class;
      } else if (clDecl.equals("short")) {
        return short.class;
      } else if (clDecl.equals("int")) {
        return int.class;
      } else if (clDecl.equals("float")) {
        return float.class;
      } else if (clDecl.equals("long")) {
        return long.class;
      } else if (clDecl.equals("double")) {
        return double.class;
      } else if (clDecl.equals("void")) {
        return Void.TYPE;
      }

      //this is not a simple type use the loader
      return loader.loadClass(clDecl);
    }

    //this is an array
    int[] arrDim = new int[(clDecl.length() - ind) / 2];
    Class compClass = loadClass0(clDecl.substring(0, ind), loader);
    return java.lang.reflect.Array.newInstance(compClass, arrDim).getClass();
  }

  
  /**
   * Returns initialized JAXBContext f
   * @param interfaceMapping
   * @param loader
   * @return
   * @throws ClassNotFoundException 
   * @throws JAXBException 
   */
  public static JAXBContext createJAXBContext(InterfaceMapping interfaceMapping, ClassLoader seiLoader) throws ClassNotFoundException, JAXBException {
    String[] classNames = extractUsedClassNames(interfaceMapping);
    Class[] loadedClasses = loadClasses(classNames,seiLoader);
    JAXBContext jaxbContext = JAXBContext.newInstance(loadedClasses);
    return jaxbContext;
  }
  
  /**
   * Returns a array of class names of all the java classes which are utilized by the
   * methods of <code>interfaceMapping</code>. The <code>interfaceMapping</code> is supposed
   * to be generated by JaxWSIMappingGenerator class.
   * @param interfaceMapping
   * @return
   */
  public static String[] extractUsedClassNames(InterfaceMapping interfaceMapping) {
    Set<String> allClasses = new HashSet<String>();
    OperationMapping[] operationMappings = interfaceMapping.getOperation(); 
    if(operationMappings == null || operationMappings.length == 0) {
      return new String[0];   
    }
    
    for(OperationMapping operationMapping: operationMappings) {
      getParamClassNames(operationMapping, allClasses); 
    }
    
    String[] paramClassNames = allClasses.toArray(new String[allClasses.size()]);
    return paramClassNames;
  } 
  
  private static void getParamClassNames(OperationMapping operationMapping, Set<String> paramClassNames) {
    ParameterMapping[] parameterMappings = null;
    String reqWBean = operationMapping.getProperty(OperationMapping.REQUEST_WRAPPER_BEAN);
    String respWBean = operationMapping.getProperty(OperationMapping.RESPONSE_WRAPPER_BEAN);    
    if (reqWBean!= null && OperationMapping.DOCUMENT_OPERATION_STYLE.equals(operationMapping.getProperty(OperationMapping.OPERATION_STYLE))) {      
      if (reqWBean != null) {
        paramClassNames.add(reqWBean);
      }
      if (respWBean != null) {
        paramClassNames.add(respWBean);
      }
      parameterMappings = operationMapping.getParameters(ParameterMapping.FAULT_TYPE); //for document operation only fault parameter need to be processed
    } else {
      parameterMappings = operationMapping.getParameter();
    }

    String paramClassName; 
    for(ParameterMapping parameterMapping: parameterMappings) {
      paramClassName = parameterMapping.getProperty(ParameterMapping.JAXB_BEAN_CLASS);    
      if(paramClassName == null) { //this is necessary for faults. They have JAXB bean class and javaType as well. But javaType must not by passed to the JAXBContext. 
        paramClassName = parameterMapping.getJavaType(); 
      }
      if(paramClassName != null) {
        paramClassNames.add(paramClassName);    
      }
    }    
  }  
}
