/*
 * Generated by SAP SchemaToJava Generator NW05 on Wed Nov 10 18:12:45 EET 2004
 * Copyright (c) 2002 by SAP Labs Sofia AG.
 * url: http://www.saplabs.bg
 * All rights reserved.
 */
package com.sap.engine.services.webservices.espbase.mappings;

import static com.sap.engine.services.webservices.espbase.mappings.InterfaceMapping.JAVA_DOC;

import java.util.ArrayList;
import java.util.List;

/**
 * WSDL PortType operation mapping to java operation.
 * Schema complexType Java representation.
 * Represents type {http://sapframework.sap.com}OperationMapping
 */
public  class OperationMapping extends com.sap.engine.services.webservices.espbase.mappings.MappingContext implements java.io.Serializable,java.lang.Cloneable {
  
  public static final String WSDL_OPERATION_NAME = "WSDLOperationName";
  public static final String JAVA_METHOD_NAME = "JavaOperationName";
  public static final String SOAP_ACTION = "SoapAction";
  public static final String SOAP_REQUEST_WRAPPER = "SoapRequestWrapper";
  public static final String SOAP_RESPONSE_WRAPPER = "SoapResponseWrapper";
  public static final String INPUT_NAMESPACE = "InputNamespace";
  public static final String OUTPUT_NAMESPACE = "OutputNamespace";
  public static final String OMIT_RESPONSE_PART_WRAPPER = "OmitResponsePartWrapper";
  public static final String OPERATION_STYLE = "OperationStyle"; // "document"/"rpc"
  public static final String OPERATION_USE = "OperationUse"; // "encoded"/literal"
  public static final String IN_ENCODING_STYLE = "InEncodingStyle";
  public static final String OUT_ENCODING_STYLE = "OutEncodingStyle"; 
  public static final String OPERATION_MEP = "OperationMep";
  public static final String MEP_ONE_WAY = "mep_one_way";
  public static final String MEP_REQ_RESP = "mep_req_resp";
  public static final String JAVA_DOC = "JavaDoc";
  public static final String REQUEST_WRAPPER_BEAN = "RequestWrapperBean";
  public static final String RESPONSE_WRAPPER_BEAN = "ResponseWrapperBean";
  public static final String ASYNC_METHODS = "AsyncMethods";
  public static final String DOCUMENT_BARE_OPERATION_STYLE = "document-bare";
  public static final String RPC_OPERATION_STYLE = "rpc";
  public static final String DOCUMENT_OPERATION_STYLE = "document";
  //@WebParam(partName="Bla"..) annotation can be used to define the <wsdl:part name> property in the WSDL!
  //These properties are only used for doc-bare currently
  public static final String DOCUMENT_BARE_OPERATION_REQ_PARTNAME = "documentbare_req_partname";
  public static final String DOCUMENT_BARE_OPERATION_RESP_PARTNAME = "documentbare_resp_partname";
  public static final String HTTP_LOCATION = "HTTPLocation";
  public static final String HTTP_INPUT_SERIALIZATION_TYPE = "HTTPInputSErializationType";
  
  /**
   * A valid values for <code>OPERATION_USE</code> property
   */
  public static final String ENCODED_USE  =  "encoded";
  public static final String LITERAL_USE  =  "literal";
  /**
   * Constant which is used in document wsdl generation, for creation of operation
   * output element. 
   * According to BP1.1 body child element for RPC style
   * should be <OperationWSDLName> + "Response".
   * Same convention is used for document operation output element name. 
   */
  public static final String OPERATION_RESPONSE_SUFFIX = "Response";
  
  /**
   * Sets WSDL Operation name. Must be valid WSDL operation in the containing PortType.
   * @param operationName
   */ 
  public void setWSDLOperationName(String operationName) {
    super.setProperty(WSDL_OPERATION_NAME,operationName);    
  }
  
  /**
   * Sets mapped Java operation name.
   * @param methodName
   */
  public void setJavaMethodName(String methodName) { 
    super.setProperty(JAVA_METHOD_NAME,methodName);
  }
  
  /**
   * Gets WSDL operation name.
   * @param operation
   * @return
   */
  public String getWSDLOperationName() {
    return super.getProperty(WSDL_OPERATION_NAME);
  }
  
  /**
   * Returns java method name.
   * @return
   */
  public String getJavaMethodName() {
    return super.getProperty(JAVA_METHOD_NAME);
  }
  
  // Element field for element {}parameter
  private ArrayList<ParameterMapping> _f_Parameter = new ArrayList<ParameterMapping>();
  /**
   * Set method for element {}parameter
   */
  public void setParameter(ParameterMapping[] _Parameter) {
    _f_Parameter.clear();
    if (_Parameter != null) {
      for (int i=0; i<_Parameter.length; i++) {
        if (_Parameter[i] != null) {
          _f_Parameter.add(_Parameter[i]);    
        }
      }
    }
  }
  /**
   * Get method for element {}parameter
   */
  public ParameterMapping[] getParameter() {
    ParameterMapping[] result = new ParameterMapping[_f_Parameter.size()];
    _f_Parameter.toArray(result);
    return result;
  }
  
  /**
   * Removes parameter from operation.
   * @param parameterMapping
   * @return
   */
  public boolean removeParameter(ParameterMapping parameterMapping) {
    return _f_Parameter.remove(parameterMapping);
  }
  
  /**
   * Removes paramter with passed WSDL parameter name and parameter type.
   * @param parameterName
   * @param parameterType
   * @return
   */
  public boolean removeParameterByWSDLName(String parameterName, int parameterType) {
    for (int i=0; i<_f_Parameter.size(); i++) {
      ParameterMapping param  = (ParameterMapping) _f_Parameter.get(i);
      if ( param.getWSDLParameterName().equals(parameterName) && (param.getParameterType() == parameterType)) {
        _f_Parameter.remove(i);
        return true;
      }      
    }
    return false;
  }  
  
  /**
   * Add method for element {}parameter
   * @param _Parameter
   */
  public void addParameter(ParameterMapping _Parameter) {
    if (_Parameter != null) {
      _f_Parameter.add(_Parameter);  
    }
  }
  /**
   * This method checks the NAMESPACE property of all ParameterMapping object
   * ,which types fulfil specified <code>mask</code>,
   * If they all have equal value, and the value is not null, true is returned, 
   * false otherwise. 
   */
  public boolean useQualifiedSchemaForParams(int mask) {
    ParameterMapping pMap[] = getParameters(mask);
    String value = null;
    for (int i = 0; i < pMap.length; i++) {
      if (! pMap[i].isHeader()) { //check only params that are not headers
        if (value == null) {
          value = pMap[i].getNamespace();
        }
        if (value != null && (! value.equals(pMap[i].getNamespace()))) {
          return false;
        }
      }
    }
    if (value != null) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * Returns ParamterMapping array, in same order as set, where the parameter types (IN, OUT...) match the <b>mask</b> parameter. 
   * @param mask Mask constructed from parameter types using | operator. 
   *             Example: ParameterMapping.IN_TYPE | Parameter.OUT_TYPE. Returns array 
   */ 
  public ParameterMapping[] getParameters(int mask) {
    ParameterMapping p;
    List<ParameterMapping> list = new ArrayList<ParameterMapping>();
    for (int i = 0; i < _f_Parameter.size(); i++) {
      p = (ParameterMapping) _f_Parameter.get(i);
      if ((mask & p.getParameterType()) != 0) {
        list.add(p);    
      }
    }
    return (ParameterMapping[]) list.toArray(new ParameterMapping[list.size()]);
  }
  /**
   * Returns flag value, which is relevant for 
   * server side processing.  
   */
  public boolean getOmitResponsePartWrapper() {
    if (super.getProperty(OMIT_RESPONSE_PART_WRAPPER) == null) {
      return false;
    }
    return Boolean.valueOf(super.getProperty(OMIT_RESPONSE_PART_WRAPPER)).booleanValue(); 
  }
  
  /**
   * Returns javaDoc for the interface.
   * @return
   */
  public String getJavaDoc() {
    return super.getProperty(JAVA_DOC);
  }
  
  /**
   * Sets javaDoc for the interface.
   * @param javaDoc
   */
  public void setJavaDoc(String javaDoc) {
    super.setProperty(JAVA_DOC, javaDoc);
  }

  /**
   * Setter for HTTP location attribute. The method is relative only for HTTP binding.
   * @return
   */
  public void setHTTPLocation(String httpLocation) {
    setProperty(HTTP_LOCATION, httpLocation);
  }
  
  /**
   * Getter for HTTP location attribute. The method is relative only for HTTP binding.
   * @return
   */
  public String getHTTPLocation() {
    return(getProperty(HTTP_LOCATION));
  }
  
  /**
   * Setter for HTTP input serialization type. The method is relative only for HTTP binding.
   * @return
   */
  public void setHTTPInputSerializationType(String httpInputSerialziation) {
    setProperty(HTTP_INPUT_SERIALIZATION_TYPE, httpInputSerialziation);
  }
  
  /**
   * Getter for HTTP input serialization type. The method is relative only for HTTP binding.
   * @return
   */
  public String getHTTPInputSerializationType() {
    return(getProperty(HTTP_INPUT_SERIALIZATION_TYPE));
  }
  
  public Object clone() throws CloneNotSupportedException {
    OperationMapping result = (OperationMapping) super.clone();
    result._f_Parameter = new ArrayList<ParameterMapping>(this._f_Parameter.size());
    for (int i=0; i < this._f_Parameter.size(); i++) {
      result._f_Parameter.add((ParameterMapping) this._f_Parameter.get(i).clone());
    }
    return result;
  }
  
}
