/*
 This file is generated by Code Generator
 for CIMClass SAP_ITSAMTransactionServiceManagementCluster
 */

package com.sap.engine.services.ts.mbeans;

import static com.sap.engine.services.ts.exceptions.ExceptionConstants.Cannot_Get_Transaction_Statistics;
import static com.sap.engine.services.ts.exceptions.ExceptionConstants.Transaction_Statistics_May_Not_Be_Full;
import static com.sap.engine.services.ts.exceptions.ExceptionConstants.Cannot_Get_Pending_Transactions;
import static com.sap.engine.services.ts.exceptions.ExceptionConstants.Pending_Transactions_May_Not_Be_Full;
import static com.sap.engine.services.ts.exceptions.ExceptionConstants.Cannot_Get_Extended_Pending_Transaction_Info;
import static com.sap.engine.services.ts.exceptions.ExceptionConstants.Unexpected_Exception_during_AbandonTransaction;
import static com.sap.engine.services.ts.exceptions.ExceptionConstants.Unexpected_Exception_during_ForgetTransaction;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.management.AttributeNotFoundException;
import javax.management.InstanceNotFoundException;
import javax.management.MBeanException;
import javax.management.MBeanServer;
import javax.management.MalformedObjectNameException;
import javax.management.ObjectName;
import javax.management.ReflectionException;
import javax.management.openmbean.CompositeData;

import com.sap.tc.logging.Location;
import com.sap.tc.logging.Severity;
import com.sap.tc.logging.SimpleLogger;

/* 
 A CIM_Service is a Logical Element that contains the information necessary to represent and manage the functionality provided by a Device and/or SoftwareFeature. A Service is a general-purpose object to configure and manage the implementation of functionality. It is not the functionality itself. 
 @version  3.3	
 */

public class SAP_ITSAMTransactionServiceManagementCluster_Impl implements
		SAP_ITSAMTransactionServiceManagementCluster {

	private static final Location location = Location
			.getLocation(SAP_ITSAMTransactionServiceManagementCluster_Impl.class
					.getName());

	private String SystemCreationClassName = null;
	private String SystemName = null;
	private String CreationClassName = null;
	private String Name = null;
	private String PrimaryOwnerName = null;
	private String PrimaryOwnerContact = null;
	private String StartMode = null;
	private boolean Started = false;
	private String OtherEnabledState = null;
	private short EnabledDefault = ENABLEDDEFAULT;
	private short RequestedState = REQUESTEDSTATE;
	private short EnabledState = ENABLEDSTATE;
	private Date TimeOfLastStateChange = null;
	private Date InstallDate = null;
	private String Status = null;
	private short[] OperationalStatus = null;
	private String[] StatusDescriptions = null;
	private String Caption = null;
	private String Description = null;
	private String ElementName = null;

	private MBeanServer mBeanServer;

	public SAP_ITSAMTransactionServiceManagementCluster_Impl(MBeanServer jmx) {
		mBeanServer = jmx;
	}

	/*
	 * 
	 * @return SAP_ITSAMTransactionStatisticsData
	 */
	public SAP_ITSAMTransactionStatisticsData getTransactionStatistics() {
		// name must be null for the overall statistics
		String name = null;

		String caption = null;
		String description = null;
		String elementName = null;

		TransactionStatisticsHolder statistics = new TransactionStatisticsHolder();

		Set<ObjectName> names;
		try {
			names = queryPerNodeMBeansNames();
		} catch (Exception e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000285", "Error while trying to query SAP_ITSAMTransactionServiceManagementNode MBean names.");

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Cannot_Get_Transaction_Statistics);
			status.setMessageParameters(new String[] {e.toString()});
			status.setStackTrace(getStackTrace(e));

			SAP_ITSAMTransactionStatisticsData res = new SAP_ITSAMTransactionStatisticsData();
			res.setActionStatus(status);
			return res;
		}

		for (ObjectName objName : names) {
			try {
				CompositeData attr_cd = (CompositeData) mBeanServer
						.getAttribute(objName, "TransactionStatistics");
				SAP_ITSAMTransactionStatisticsData attr = SAP_ITSAMTransactionServiceManagementClusterWrapper
						.getSAP_ITSAMTransactionStatisticsDataForCData(attr_cd);
				statistics.addTransactionStatistics(attr);

			} catch (AttributeNotFoundException e) {
				SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000292", "Cannot get TransactionStatistics attribute.");
				statistics.setActionStatus(
						SAP_ITSAMJ2eeActionStatus.ERROR_CODE, Cannot_Get_Transaction_Statistics,
						new String[] {e.toString()}, getStackTrace(e));
				break;

			} catch (InstanceNotFoundException e) {
				SimpleLogger.traceThrowable(Severity.DEBUG, location,
						"Cannot get TransactionStatistics attribute for a server node. This node's statistics will be skipped.", e);
				statistics.setActionStatus(
						SAP_ITSAMJ2eeActionStatus.WARNING_CODE, Transaction_Statistics_May_Not_Be_Full,
						new String[] {e.toString()}, getStackTrace(e));
				continue;

			} catch (MBeanException e) {
				SimpleLogger.traceThrowable(Severity.DEBUG, location,
						"Cannot get TransactionStatistics attribute for a server node. This node's statistics will be skipped.", e);
				statistics.setActionStatus(
						SAP_ITSAMJ2eeActionStatus.WARNING_CODE, Transaction_Statistics_May_Not_Be_Full,
						new String[] {e.toString()}, getStackTrace(e));
				continue;

			} catch (ReflectionException e) {
				SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000293", "Cannot get TransactionStatistics attribute.");
				statistics.setActionStatus(
						SAP_ITSAMJ2eeActionStatus.ERROR_CODE, Cannot_Get_Transaction_Statistics,
						new String[] {e.toString()}, getStackTrace(e));
				break;

			} catch (Exception e) {
				SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000294", "Cannot get TransactionStatistics attribute.");
				statistics.setActionStatus(
						SAP_ITSAMJ2eeActionStatus.ERROR_CODE, Cannot_Get_Transaction_Statistics,
						new String[] {e.toString()}, getStackTrace(e));
				break;
			}
		}

		return statistics.toSAP_ITSAMTransactionStatisticsData(name, caption,
				description, elementName);
	}

	/*
	 * 
	 * @return SAP_ITSAMTransactionStatisticsData
	 */
	public SAP_ITSAMTransactionStatisticsData[] getTransactionStatisticsPerRM() {
		String caption = null;
		String description = null;
		String elementName = null;
		return sumTransactionStatisticsArrays("TransactionStatisticsPerRM",
				caption, description, elementName);
	}

	/*
	 * 
	 * @return SAP_ITSAMTransactionStatisticsData
	 */
	public SAP_ITSAMTransactionStatisticsData[] getTransactionStatisticsPerTxClassifier() {
		String caption = null;
		String description = null;
		String elementName = null;
		return sumTransactionStatisticsArrays(
				"TransactionStatisticsPerTxClassifier", caption, description,
				elementName);
	}

	/*
	 * 
	 * @return SAP_ITSAMPendingTransactionData
	 */
	public SAP_ITSAMPendingTransactionData[] getPendingTransactions() {
		// This overallStatus is used to report for any cluster-wide problems.
		// It's packed in SAP_ITSAMPendingTransactionData instance but the
		// instance must not be listed in the resulting list with pending
		// transaction
		SAP_ITSAMJ2eeActionStatus overallStatus = new SAP_ITSAMJ2eeActionStatus();
		overallStatus.setCode(SAP_ITSAMJ2eeActionStatus.OK_CODE);

		List<SAP_ITSAMPendingTransactionData> result = new ArrayList<SAP_ITSAMPendingTransactionData>(
				100);

		Set<ObjectName> names;
		try {
			names = queryPerNodeMBeansNames();
		} catch (Exception e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000286", "Error while trying to query SAP_ITSAMTransactionServiceManagementNode MBean names.");

			overallStatus.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			overallStatus.setMessageId(Cannot_Get_Pending_Transactions);
			overallStatus.setMessageParameters(new String[] {e.toString()});
			overallStatus.setStackTrace(getStackTrace(e));

			SAP_ITSAMPendingTransactionData res = new SAP_ITSAMPendingTransactionData();
			res.setActionStatus(overallStatus);
			return new SAP_ITSAMPendingTransactionData[] { res };
		}

		for (ObjectName objName : names) {
			try {
				CompositeData[] attr_cd = (CompositeData[]) mBeanServer
						.getAttribute(objName, "PendingTransactions");
				SAP_ITSAMPendingTransactionData[] attr = SAP_ITSAMTransactionServiceManagementClusterWrapper
						.getSAP_ITSAMPendingTransactionDataArrForCData(attr_cd);
				result.addAll(Arrays.asList(attr));

			} catch (AttributeNotFoundException e) {
				SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000295","Cannot get PendingTransactions attribute.");
				overallStatus.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
				overallStatus.setMessageId(Cannot_Get_Pending_Transactions);
				overallStatus.setMessageParameters(new String[] {e.toString()});
				overallStatus.setStackTrace(getStackTrace(e));
				break;

			} catch (InstanceNotFoundException e) {
				SimpleLogger.traceThrowable(Severity.DEBUG, location,
						"Cannot get PendingTransactions attribute for a server node. This node's pending transactions will be skipped.", e);
				overallStatus.setCode(SAP_ITSAMJ2eeActionStatus.WARNING_CODE);
				overallStatus.setMessageId(Pending_Transactions_May_Not_Be_Full);
				overallStatus.setMessageParameters(new String[] {e.toString()});
				overallStatus.setStackTrace(getStackTrace(e));
				continue;

			} catch (MBeanException e) {
				SimpleLogger.traceThrowable(Severity.DEBUG, location,
						"Cannot get PendingTransactions attribute for a server node. This node's pending transactions will be skipped.", e);
				overallStatus.setCode(SAP_ITSAMJ2eeActionStatus.WARNING_CODE);
				overallStatus.setMessageId(Pending_Transactions_May_Not_Be_Full);
				overallStatus.setMessageParameters(new String[] {e.toString()});
				overallStatus.setStackTrace(getStackTrace(e));
				continue;

			} catch (ReflectionException e) {
				SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000296","Cannot get PendingTransactions attribute.");
				overallStatus.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
				overallStatus.setMessageId(Cannot_Get_Pending_Transactions);
				overallStatus.setMessageParameters(new String[] {e.toString()});
				overallStatus.setStackTrace(getStackTrace(e));
				break;

			} catch (Exception e) {
				SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000297","Cannot get PendingTransactions attribute.");
				overallStatus.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
				overallStatus.setMessageId(Cannot_Get_Pending_Transactions);
				overallStatus.setMessageParameters(new String[] {e.toString()});
				overallStatus.setStackTrace(getStackTrace(e));
				break;
			}
		}

		// Pack the overallStatus in SAP_ITSAMPendingTransactionData and put it
		// in the result array
		SAP_ITSAMPendingTransactionData statusTx = new SAP_ITSAMPendingTransactionData();
		statusTx.setActionStatus(overallStatus);
		result.add(statusTx);
		return result
				.toArray(new SAP_ITSAMPendingTransactionData[result.size()]);
	}

	/*
	 * The scoping System's CreationClassName.
	 * 
	 * @return String
	 */
	public String getSystemCreationClassName() {
		return SystemCreationClassName;
	}

	/*
	 * The scoping System's Name.
	 * 
	 * @return String
	 */
	public String getSystemName() {
		return SystemName;
	}

	/*
	 * CreationClassName indicates the name of the class or the subclass used in
	 * the creation of an instance. When used with the other key properties of
	 * this class, this property allows all instances of this class and its
	 * subclasses to be uniquely identified.
	 * 
	 * @return String
	 */
	public String getCreationClassName() {
		return CreationClassName;
	}

	/*
	 * The Name property uniquely identifies the Service and provides an
	 * indication of the functionality that is managed. This functionality is
	 * described in more detail in the object's Description property.
	 * 
	 * @return String
	 */
	public String getName() {
		return Name;
	}

	/*
	 * The name of the primary owner for the service, if one is defined. The
	 * primary owner is the initial support contact for the Service.
	 * 
	 * @return String
	 */
	public String getPrimaryOwnerName() {
		return PrimaryOwnerName;
	}

	/*
	 * @param String
	 */
	public void setPrimaryOwnerName(String PrimaryOwnerName) {
		this.PrimaryOwnerName = PrimaryOwnerName;
	}

	/*
	 * A string that provides information on how the primary owner of the
	 * Service can be reached (e.g. phone number, email address, ...).
	 * 
	 * @return String
	 */
	public String getPrimaryOwnerContact() {
		return PrimaryOwnerContact;
	}

	/*
	 * @param String
	 */
	public void setPrimaryOwnerContact(String PrimaryOwnerContact) {
		this.PrimaryOwnerContact = PrimaryOwnerContact;
	}

	/*
	 * StartMode is a string value indicating whether the Service is
	 * automatically started by a System, Operating System, etc. or only started
	 * upon request. This property is deprecated in lieu of the EnabledDefault
	 * property inherited from EnabledLogicalElement, which addresses the same
	 * semantics. The change to a uint16 data type was discussed when CIM V2.0
	 * was defined. However, existing V1.0 implementations used the string
	 * property and did not want to modify their code. Therefore, StartMode was
	 * grandfathered into the Schema. Use of the Deprecated qualifier allows the
	 * maintenance of the existing property, but also permits an improved,
	 * clarified definition using EnabledDefault.
	 * 
	 * @return String
	 */
	public String getStartMode() {
		return StartMode;
	}

	/*
	 * Started is a boolean indicating whether the Service has been started
	 * (TRUE), or stopped (FALSE).
	 * 
	 * @return boolean
	 */
	public boolean getStarted() {
		return Started;
	}

	/*
	 * EnabledState is an integer enumeration that indicates the
	 * enabled/disabled states of an element. It can also indicate the
	 * transitions between these requested states. For example, shutting down
	 * (value = 4) and starting (value=10) are transient states between enabled
	 * and disabled. The following text briefly summarizes the various
	 * enabled/disabled states: Enabled (2) indicates that the element is/could
	 * be executing commands, will process any queued commands, and queues new
	 * requests. Disabled (3) indicates that the element will not execute
	 * commands and will drop any new requests. Shutting Down (4) indicates that
	 * the element is in the process of going to a Disabled state. Not
	 * Applicable (5) indicates the element doesn't support being
	 * enabled/disabled. Enabled but Offline (6) indicates that the element may
	 * be completing commands, and will drop any new requests. Test (7)
	 * indicates that the element is in a test state. Deferred (8) indicates
	 * that the element may be completing commands, but will queue any new
	 * requests. Quiesce (9) indicates that the element is enabled but in a
	 * restricted mode. The element's behavior is similar to the Enabled state,
	 * but it only processes a restricted set of commands. All other requests
	 * are queued. Starting (10) indicates that the element is in the process of
	 * going to an Enabled state. New requests are queued.
	 * 
	 * @return short
	 */
	public short getEnabledState() {
		return EnabledState;
	}

	/*
	 * A string describing the element's enabled/disabled state when the
	 * EnabledState property is set to 1 ("Other"). This property MUST be set to
	 * NULL when EnabledState is any value other than 1.
	 * 
	 * @return String
	 */
	public String getOtherEnabledState() {
		return OtherEnabledState;
	}

	/*
	 * RequestedState is an integer enumeration indicating the last requested or
	 * desired state for the element. The actual state of the element is
	 * represented by EnabledState. This property is provided to compare the
	 * last requested and current enabled/disabled states. Note that when
	 * EnabledState is set to 5 ("Not Applicable"), then this property has no
	 * meaning. By default, the element's RequestedState is 5 ("No Change").
	 * Refer to the EnabledState's property Description for explanations of the
	 * values in the RequestedState enumeration.
	 * 
	 * It should be noted that there are two new values in RequestedState that
	 * build on the statuses of EnabledState. These are "Reboot" (10) and
	 * "Reset" (11). The former, Reboot, refers to doing a "Shut Down" and then
	 * moving to an "Enabled" state. The latter, Reset, indicates that the
	 * element is first "Disabled" and then "Enabled". The distinction between
	 * requesting "Shut Down" and "Disabled" should also be noted. The former,
	 * Shut Down, requests an orderly transition to the Disabled state, and MAY
	 * involve removing power, to completely erase any existing state. The
	 * latter, the Disabled state, requests an immediate disabling of the
	 * element, such that it will not execute or accept any commands or
	 * processing requests.
	 * 
	 * This property is set as the result of a method invocation (such as Start
	 * or StopService on CIM_Service), or may be overridden and defined as
	 * WRITEable in a subclass. The method approach is considered superior to a
	 * WRITEable property, since it allows an explicit invocation of the
	 * operation and the return of a result code.
	 * 
	 * @return short
	 */
	public short getRequestedState() {
		return RequestedState;
	}

	/*
	 * An enumerated value indicating an administrator's default/startup
	 * configuration for an element's Enabled State. By default, the element is
	 * "Enabled" (value=2).
	 * 
	 * @return short
	 */
	public short getEnabledDefault() {
		return EnabledDefault;
	}

	/*
	 * @param short
	 */
	public void setEnabledDefault(short EnabledDefault) {
		this.EnabledDefault = EnabledDefault;
	}

	/*
	 * The date/time when the element's EnabledState last changed. If the state
	 * of the element has not changed and this property is populated, then it
	 * MUST be set to a 0 interval value. If a state change was requested, but
	 * rejected or not yet processed, the property MUST NOT be updated.
	 * 
	 * @return Date
	 */
	public Date getTimeOfLastStateChange() {
		return TimeOfLastStateChange;
	}

	/*
	 * A datetime value indicating when the object was installed. A lack of a
	 * value does not indicate that the object is not installed.
	 * 
	 * @return Date
	 */
	public Date getInstallDate() {
		return InstallDate;
	}

	/*
	 * A string indicating the current status of the object. Various operational
	 * and non-operational statuses are defined. This property is deprecated in
	 * lieu of OperationalStatus, which includes the same semantics in its
	 * enumeration. This change is made for 3 reasons: 1) Status is more
	 * correctly defined as an array. This overcomes the limitation of
	 * describing status via a single value, when it is really a multi-valued
	 * property (for example, an element may be OK AND Stopped. 2) A MaxLen of
	 * 10 is too restrictive and leads to unclear enumerated values. And, 3) The
	 * change to a uint16 data type was discussed when CIM V2.0 was defined.
	 * However, existing V1.0 implementations used the string property and did
	 * not want to modify their code. Therefore, Status was grandfathered into
	 * the Schema. Use of the Deprecated qualifier allows the maintenance of the
	 * existing property, but also permits an improved definition using
	 * OperationalStatus.
	 * 
	 * @return String
	 */
	public String getStatus() {
		return Status;
	}

	/*
	 * Indicates the current status(es) of the element. Various health and
	 * operational statuses are defined. Many of the enumeration's values are
	 * self- explanatory. However, a few are not and are described in more
	 * detail. "Stressed" indicates that the element is functioning, but needs
	 * attention. Examples of "Stressed" states are overload, overheated, etc.
	 * "Predictive Failure" indicates that an element is functioning nominally
	 * but predicting a failure in the near future. "In Service" describes an
	 * element being configured, maintained, cleaned, or otherwise administered.
	 * "No Contact" indicates that the monitoring system has knowledge of this
	 * element, but has never been able to establish communications with it.
	 * "Lost Communication" indicates that the ManagedSystem Element is known to
	 * exist and has been contacted successfully in the past, but is currently
	 * unreachable. "Stopped" and "Aborted" are similar, although the former
	 * implies a clean and orderly stop, while the latter implies an abrupt stop
	 * where the element's state and configuration may need to be updated.
	 * "Dormant" indicates that the element is inactive or quiesced.
	 * "Supporting Entity in Error" describes that this element may be "OK" but
	 * that another element, on which it is dependent, is in error. An example
	 * is a network service or endpoint that cannot function due to lower layer
	 * networking problems. "Completed" indicates the element has completed its
	 * operation. This value should be combined with either OK, Error, or
	 * Degraded so that a client can till if the complete operation passed
	 * (Completed with OK), and failure (Completed with Error). Completed with
	 * Degraded would imply the operation finished, but did not complete OK or
	 * report an error. "Power Mode" indicates the element has additional power
	 * model information contained in the Associated PowerManagementService
	 * association. OperationalStatus replaces the Status property on
	 * ManagedSystemElement to provide a consistent approach to enumerations, to
	 * address implementation needs for an array property, and to provide a
	 * migration path from today's environment to the future. This change was
	 * not made earlier since it required the DEPRECATED qualifier. Due to the
	 * widespread use of the existing Status property in management
	 * applications, it is strongly RECOMMENDED that providers/instrumentation
	 * provide BOTH the Status and OperationalStatus properties. Further, the
	 * first value of OperationalStatus SHOULD contain the primary status for
	 * the element. When instrumented, Status (since it is single-valued) SHOULD
	 * also provide the primary status of the element.
	 * 
	 * @return short
	 */
	public short[] getOperationalStatus() {
		return OperationalStatus;
	}

	/*
	 * Strings describing the various OperationalStatus array values. For
	 * example, if "Stopping" is the value assigned to OperationalStatus, then
	 * this property may contain an explanation as to why an object is being
	 * stopped. Note that entries in this array are correlated with those at the
	 * same array index in OperationalStatus.
	 * 
	 * @return String
	 */
	public String[] getStatusDescriptions() {
		return StatusDescriptions;
	}

	/*
	 * The Caption property is a short textual description (one- line string) of
	 * the object.
	 * 
	 * @return String
	 */
	public String getCaption() {
		return Caption;
	}

	/*
	 * The Description property provides a textual description of the object.
	 * 
	 * @return String
	 */
	public String getDescription() {
		return Description;
	}

	/*
	 * A user-friendly name for the object. This property allows each instance
	 * to define a user-friendly name IN ADDITION TO its key properties/identity
	 * data, and description information. Note that ManagedSystemElement's Name
	 * property is also defined as a user-friendly name. But, it is often
	 * subclassed to be a Key. It is not reasonable that the same property can
	 * convey both identity and a user friendly name, without inconsistencies.
	 * Where Name exists and is not a Key (such as for instances of
	 * LogicalDevice), the same information MAY be present in both the Name and
	 * ElementName properties.
	 * 
	 * @return String
	 */
	public String getElementName() {
		return ElementName;
	}

	public SAP_ITSAMExtendedPendingTransactionData retrievePendingTransactionInfo(
			String systemId, int nodeId, long tmStartupTime,
			long transactionSeqNumber) {

		ObjectName mBeanName;
		try {
			mBeanName = queryMBeanForNode(nodeId);
		} catch (Exception e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000289","Error while trying to query SAP_ITSAMTransactionServiceManagementNode MBean name for {0} cluster node.", new Object[] {nodeId});
					
			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Cannot_Get_Extended_Pending_Transaction_Info);
			status.setMessageParameters(new String[] {Long.toString(transactionSeqNumber), e.toString()});
			status.setStackTrace(getStackTrace(e));

			SAP_ITSAMExtendedPendingTransactionData res = new SAP_ITSAMExtendedPendingTransactionData();
			res.setActionStatus(status);
			return res;
		}

		try {
			CompositeData pti = (CompositeData) mBeanServer.invoke(mBeanName,
					"retrievePendingTransactionInfo", new Object[] { systemId,
							nodeId, tmStartupTime, transactionSeqNumber },
					new String[] { String.class.getName(), int.class.getName(),
							long.class.getName(), long.class.getName() });

			return SAP_ITSAMTransactionServiceManagementClusterWrapper
					.getSAP_ITSAMExtendedPendingTransactionDataForCData(pti);

		} catch (InstanceNotFoundException e) {
			SimpleLogger.traceThrowable(Severity.DEBUG, location,
					"Cannot get pending transaction info for server node "
							+ nodeId, e);

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Cannot_Get_Extended_Pending_Transaction_Info);
			status.setMessageParameters(new String[] {Long.toString(transactionSeqNumber), e.toString()});
			status.setStackTrace(getStackTrace(e));

			SAP_ITSAMExtendedPendingTransactionData res = new SAP_ITSAMExtendedPendingTransactionData();
			res.setActionStatus(status);
			return res;

		} catch (MBeanException e) {
			SimpleLogger.traceThrowable(Severity.DEBUG, location,
					"Cannot get pending transaction info for server node "
							+ nodeId, e);

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Cannot_Get_Extended_Pending_Transaction_Info);
			status.setMessageParameters(new String[] {Long.toString(transactionSeqNumber), e.toString()});
			status.setStackTrace(getStackTrace(e));

			SAP_ITSAMExtendedPendingTransactionData res = new SAP_ITSAMExtendedPendingTransactionData();
			res.setActionStatus(status);
			return res;

		} catch (ReflectionException e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000298","Cannot get pending transaction info for server node {0}", new Object[] { nodeId});

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Cannot_Get_Extended_Pending_Transaction_Info);
			status.setMessageParameters(new String[] {Long.toString(transactionSeqNumber), e.toString()});
			status.setStackTrace(getStackTrace(e));

			SAP_ITSAMExtendedPendingTransactionData res = new SAP_ITSAMExtendedPendingTransactionData();
			res.setActionStatus(status);
			return res;

		} catch (Exception e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000299","Cannot get pending transaction info for server node {0}", new Object[] { nodeId});
			
			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Cannot_Get_Extended_Pending_Transaction_Info);
			status.setMessageParameters(new String[] {Long.toString(transactionSeqNumber), e.toString()});
			status.setStackTrace(getStackTrace(e));

			SAP_ITSAMExtendedPendingTransactionData res = new SAP_ITSAMExtendedPendingTransactionData();
			res.setActionStatus(status);
			return res;
		}
	}

	public SAP_ITSAMJ2eeActionStatus abandonTransaction(String systemId,
			int nodeId, long tmStartupTime, long transactionSeqNumber) {

		ObjectName mBeanName;
		try {
			mBeanName = queryMBeanForNode(nodeId);
		} catch (Exception e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000290","Error while trying to query SAP_ITSAMTransactionServiceManagementNode MBean name for {0} cluster node.", new Object[] {nodeId});

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Unexpected_Exception_during_AbandonTransaction);
			status.setMessageParameters(new String[] { Long.toString(transactionSeqNumber), e.toString() });
			return status;
		}

		try {
			CompositeData error_cd = (CompositeData) mBeanServer.invoke(
					mBeanName, "abandonTransaction", new Object[] { systemId,
							nodeId, tmStartupTime, transactionSeqNumber },
					new String[] { String.class.getName(), int.class.getName(),
							long.class.getName(), long.class.getName() });
			return SAP_ITSAMTransactionServiceManagementClusterWrapper
					.getSAP_ITSAMJ2eeActionStatusForCData(error_cd);

		} catch (InstanceNotFoundException e) {
			SimpleLogger.traceThrowable(Severity.DEBUG, location,
					"Cannot abandon transaction in server node "
							+ nodeId, e);

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Unexpected_Exception_during_AbandonTransaction);
			status.setMessageParameters(new String[] { Long.toString(transactionSeqNumber), e.toString() });
			status.setStackTrace(getStackTrace(e));
			return status;

		} catch (MBeanException e) {
			SimpleLogger.traceThrowable(Severity.DEBUG, location,
					"Cannot abandon transaction in server node "
							+ nodeId, e);

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Unexpected_Exception_during_AbandonTransaction);
			status.setMessageParameters(new String[] { Long.toString(transactionSeqNumber), e.toString() });
			status.setStackTrace(getStackTrace(e));
			return status;

		} catch (ReflectionException e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000300","Cannot abandon transaction in server node {0}", new Object[]{nodeId});

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Unexpected_Exception_during_AbandonTransaction);
			status.setMessageParameters(new String[] { Long.toString(transactionSeqNumber), e.toString() });
			status.setStackTrace(getStackTrace(e));
			return status;

		} catch (Exception e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000301","Cannot abandon transaction in server node {0}", new Object[]{nodeId});
			
			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Unexpected_Exception_during_AbandonTransaction);
			status.setMessageParameters(new String[] { Long.toString(transactionSeqNumber), e.toString() });
			status.setStackTrace(getStackTrace(e));
			return status;
		}
	}

	public SAP_ITSAMJ2eeActionStatus forgetTransaction(String systemId,
			int nodeId, long tmStartupTime, long transactionSeqNumber) {

		ObjectName mBeanName;
		try {
			mBeanName = queryMBeanForNode(nodeId);
		} catch (Exception e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000291","Error while trying to query SAP_ITSAMTransactionServiceManagementNode MBean name for {0} cluster node.", new Object[] {nodeId});

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Unexpected_Exception_during_ForgetTransaction);
			status.setMessageParameters(new String[] { Long.toString(transactionSeqNumber), e.toString() });
			return status;
		}

		try {
			CompositeData error_cd = (CompositeData) mBeanServer.invoke(
					mBeanName, "forgetTransaction", new Object[] { systemId,
							nodeId, tmStartupTime, transactionSeqNumber },
					new String[] { String.class.getName(), int.class.getName(),
							long.class.getName(), long.class.getName() });
			return SAP_ITSAMTransactionServiceManagementClusterWrapper
					.getSAP_ITSAMJ2eeActionStatusForCData(error_cd);

		} catch (InstanceNotFoundException e) {
			SimpleLogger.traceThrowable(Severity.DEBUG, location,
					"Cannot forget transaction in server node "
							+ nodeId, e);

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Unexpected_Exception_during_ForgetTransaction);
			status.setMessageParameters(new String[] { Long.toString(transactionSeqNumber), e.toString() });
			status.setStackTrace(getStackTrace(e));
			return status;

		} catch (MBeanException e) {
			SimpleLogger.traceThrowable(Severity.DEBUG, location,
					"Cannot forget transaction in server node "
							+ nodeId, e);

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Unexpected_Exception_during_ForgetTransaction);
			status.setMessageParameters(new String[] { Long.toString(transactionSeqNumber), e.toString() });
			status.setStackTrace(getStackTrace(e));
			return status;

		} catch (ReflectionException e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000302","Cannot forget transaction in server node {0}", new Object[]{nodeId});

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Unexpected_Exception_during_ForgetTransaction);
			status.setMessageParameters(new String[] { Long.toString(transactionSeqNumber), e.toString() });
			status.setStackTrace(getStackTrace(e));
			return status;

		} catch (Exception e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000303","Cannot forget transaction in server node {0}", new Object[]{nodeId});

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Unexpected_Exception_during_ForgetTransaction);
			status.setMessageParameters(new String[] { Long.toString(transactionSeqNumber), e.toString() });
			status.setStackTrace(getStackTrace(e));
			return status;
		}
	}

	public void clearTransactionsStatistics() {
		Set<ObjectName> names;
		try {
			names = queryPerNodeMBeansNames();
		} catch (Exception e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000287", "Error while trying to query SAP_ITSAMTransactionServiceManagementNode MBean names.");
			return;
		}

		for (ObjectName objName : names) {
			try {
				mBeanServer.invoke(objName, "clearTransactionsStatistics",
						new Object[] {}, new String[] {});
			} catch (InstanceNotFoundException e) {
				SimpleLogger.traceThrowable(Severity.DEBUG, location,
						"Cannot clear transaction statistics in a server node. This node's statistics will not be cleared.", e);
				continue;
			} catch (MBeanException e) {
				SimpleLogger.traceThrowable(Severity.DEBUG, location,
						"Cannot clear transaction statistics in a server node. This node's statistics will not be cleared.", e);
				continue;
			} catch (ReflectionException e) {
				SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000304","Cannot clear transaction statistics in a server node. This node's statistics will not be cleared.");
				continue;
			} catch (Exception e) {
				SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000305","Cannot clear transaction statistics in a server node. This node's statistics will not be cleared.");
				continue;
			}
		}
	}

	public void StartService() {
	}

	public void StopService() {
	}

	public ObjectName RequestStateChange(short RequestedState,
			Date TimeoutPeriod) {
		this.RequestedState = RequestedState;
		return null;
	}

	// Helpful Methods
	private Set<ObjectName> queryPerNodeMBeansNames() {
		try {
			return mBeanServer.queryNames(new ObjectName(
					"*:*,cimclass=SAP_ITSAMTransactionServiceManagementNode"),
					null);
		} catch (MalformedObjectNameException e) {
			throw new IllegalStateException(
					"Cannot lookup SAP_ITSAMTransactionServiceManagementNode MBean.",
					e);
		} catch (NullPointerException e) {
			throw new IllegalStateException(
					"Cannot lookup SAP_ITSAMTransactionServiceManagementNode MBean.",
					e);
		}
	}

	private ObjectName queryMBeanForNode(int nodeId) {
		try {
			Set<ObjectName> names = mBeanServer.queryNames(new ObjectName(
					"*:*,cimclass=SAP_ITSAMTransactionServiceManagementNode,SAP_J2EEClusterNode="
							+ nodeId), null);
			if (names.size() != 1) {
				throw new IllegalStateException(
						"Cannot lookup single SAP_ITSAMTransactionServiceManagementNode MBean for node "
								+ nodeId);
			}
			return names.iterator().next();

		} catch (MalformedObjectNameException e) {
			throw new IllegalStateException(
					"Cannot lookup single SAP_ITSAMTransactionServiceManagementNode MBean for node "
							+ nodeId);

		} catch (NullPointerException e) {
			throw new IllegalStateException(
					"Cannot lookup single SAP_ITSAMTransactionServiceManagementNode MBean for node "
							+ nodeId);
		}
	}

	private SAP_ITSAMTransactionStatisticsData[] sumTransactionStatisticsArrays(
			String attributeName, String caption, String description,
			String elementName) {
		Map<String, TransactionStatisticsHolder> statistics = new HashMap<String, TransactionStatisticsHolder>();

		Set<ObjectName> mBeansNames;
		try {
			mBeansNames = queryPerNodeMBeansNames();
		} catch (Exception e) {
			SimpleLogger.traceThrowable(Severity.ERROR, location,e,"ASJ.trans.000288", "Error while trying to query SAP_ITSAMTransactionServiceManagementNode MBean names.");

			SAP_ITSAMJ2eeActionStatus status = new SAP_ITSAMJ2eeActionStatus();
			status.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			status.setMessageId(Cannot_Get_Transaction_Statistics);
			status.setMessageParameters(new String[] {e.toString()});
			status.setStackTrace(getStackTrace(e));

			SAP_ITSAMTransactionStatisticsData res = new SAP_ITSAMTransactionStatisticsData();
			res.setActionStatus(status);
			return new SAP_ITSAMTransactionStatisticsData[] { res };
		}

		for (ObjectName objName : mBeansNames) {
			try {
				CompositeData[] attr_cd = (CompositeData[]) mBeanServer
						.getAttribute(objName, attributeName);
				SAP_ITSAMTransactionStatisticsData[] attributes = SAP_ITSAMTransactionServiceManagementClusterWrapper
						.getSAP_ITSAMTransactionStatisticsDataArrForCData(attr_cd);
				for (SAP_ITSAMTransactionStatisticsData attr : attributes) {
					String statsName = attr.getName();
					if (statistics.containsKey(statsName)) {
						statistics.get(statsName)
								.addTransactionStatistics(attr);
					} else {
						statistics.put(statsName,
								new TransactionStatisticsHolder(attr));
					}
				}

			} catch (AttributeNotFoundException e) {
				SimpleLogger.traceThrowable(Severity.ERROR, location, e,"ASJ.trans.000306","Cannot get {0} attribute.", new Object[] {attributeName});

				String stackTrace = getStackTrace(e);
				for (TransactionStatisticsHolder stat : statistics.values()) {
					stat.setActionStatus(SAP_ITSAMJ2eeActionStatus.ERROR_CODE,
							Cannot_Get_Transaction_Statistics,
							new String[] {e.toString()},
							stackTrace);
				}
				break;

			} catch (InstanceNotFoundException e) {
				SimpleLogger.traceThrowable(Severity.DEBUG, location,
						"Cannot get "+ attributeName + " attribute. This node's statistics will be skipped.", e);

				String stackTrace = getStackTrace(e);
				for (TransactionStatisticsHolder stat : statistics.values()) {
					stat.setActionStatus(
							SAP_ITSAMJ2eeActionStatus.WARNING_CODE,
							Transaction_Statistics_May_Not_Be_Full,
							new String[] {e.toString()},
							stackTrace);
				}
				continue;

			} catch (MBeanException e) {
				SimpleLogger.traceThrowable(Severity.DEBUG, location,
						"Cannot get "+ attributeName + " attribute. This node's statistics will be skipped.", e);

				String stackTrace = getStackTrace(e);
				for (TransactionStatisticsHolder stat : statistics.values()) {
					stat.setActionStatus(
							SAP_ITSAMJ2eeActionStatus.WARNING_CODE,
							Transaction_Statistics_May_Not_Be_Full,
							new String[] {e.toString()},
							stackTrace);
				}
				continue;

			} catch (ReflectionException e) {
				SimpleLogger.traceThrowable(Severity.ERROR, location, e,"ASJ.trans.000307","Cannot get {0} attribute.", new Object[] {attributeName});

				String stackTrace = getStackTrace(e);
				for (TransactionStatisticsHolder stat : statistics.values()) {
					stat.setActionStatus(SAP_ITSAMJ2eeActionStatus.ERROR_CODE,
							Cannot_Get_Transaction_Statistics,
							new String[] {e.toString()},
							stackTrace);
				}
				break;

			} catch (Exception e) {
				SimpleLogger.traceThrowable(Severity.ERROR, location, e,"ASJ.trans.000308","Cannot get {0} attribute.", new Object[] {attributeName});

				String stackTrace = getStackTrace(e);
				for (TransactionStatisticsHolder stat : statistics.values()) {
					stat.setActionStatus(SAP_ITSAMJ2eeActionStatus.ERROR_CODE,
							Cannot_Get_Transaction_Statistics,
							new String[] {e.toString()},
							stackTrace);
				}
				break;
			}
		}

		SAP_ITSAMTransactionStatisticsData[] result = new SAP_ITSAMTransactionStatisticsData[statistics.size()];
		int i = 0;
		for (String statsName : statistics.keySet()) {
			result[i++] = statistics.get(statsName)
					.toSAP_ITSAMTransactionStatisticsData(statsName, caption,
							description, elementName);
		}
		return result;
	}

	private static final String getStackTrace(Throwable e) {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		(e).printStackTrace(new PrintStream(baos));
		return baos.toString();
	}

}