/*
 This file is generated by Code Generator
 for CIMClass SAP_ITSAMTransactionServiceManagementNode
 */

package com.sap.engine.services.ts.mbeans;

import java.util.Date;

import javax.management.ObjectName;

import com.sap.engine.services.ts.Util;
import com.sap.engine.services.ts.exceptions.ExceptionConstants;
import com.sap.engine.services.ts.exceptions.TSResourceAccessor;
import com.sap.engine.services.ts.jta.impl2.TXR_TransactionImpl;
import com.sap.engine.services.ts.jta.statistics.TransactionStatistics;
import com.sap.engine.services.ts.recovery.PTLProcessor;
import com.sap.engine.services.ts.recovery.PendingTXData;
import com.sap.localization.LocalizableTextFormatter;
import com.sap.localization.LocalizationException;
import com.sap.tc.logging.Location;
import com.sap.tc.logging.Severity;
import com.sap.tc.logging.SimpleLogger;

/* 
 A CIM_Service is a Logical Element that contains the information necessary to represent and manage the functionality provided by a Device and/or SoftwareFeature. A Service is a general-purpose object to configure and manage the implementation of functionality. It is not the functionality itself. 
 @version  3.3	
 */

public class SAP_ITSAMTransactionServiceManagementNode_Impl implements
		SAP_ITSAMTransactionServiceManagementNode {

	private static final Location LOCATION = Location.getLocation(SAP_ITSAMTransactionServiceManagementNode_Impl.class);	

	/*
	 * 
	 * @return SAP_ITSAMTransactionStatisticsData
	 */
	public com.sap.engine.services.ts.mbeans.SAP_ITSAMTransactionStatisticsData getTransactionStatistics() {
		return TransactionStatistics.getTransactionStatisticsData();
	}

	/*
	 * 
	 * @return SAP_ITSAMTransactionStatisticsData
	 */
	public com.sap.engine.services.ts.mbeans.SAP_ITSAMTransactionStatisticsData[] getTransactionStatisticsPerRM() {
		return TransactionStatistics.getTransactionStatisticsPerRM();
	}

	/*
	 * 
	 * @return SAP_ITSAMTransactionStatisticsData
	 */
	public com.sap.engine.services.ts.mbeans.SAP_ITSAMTransactionStatisticsData[] getTransactionStatisticsPerTxClassifier() {
		return TransactionStatistics.getTransactionStatisticsPerTxClassifier();
	}

	/*
	 * 
	 * @return SAP_ITSAMPendingTransactionData
	 */
	public com.sap.engine.services.ts.mbeans.SAP_ITSAMPendingTransactionData[] getPendingTransactions() {
		return PTLProcessor.getPendingTransactions();
	}

	/*
	 * The scoping System's CreationClassName.
	 * 
	 * @return String
	 */

	public String getSystemCreationClassName() {
		// No implementation.
		return null;

	}

	/*
	 * The scoping System's Name.
	 * 
	 * @return String
	 */

	public String getSystemName() {
		// No implementation..
		return null;

	}

	/*
	 * CreationClassName indicates the name of the class or the subclass used in
	 * the creation of an instance. When used with the other key properties of
	 * this class, this property allows all instances of this class and its
	 * subclasses to be uniquely identified.
	 * 
	 * @return String
	 */

	public String getCreationClassName() {
		// No implementation.
		return null;

	}

	/*
	 * The Name property uniquely identifies the Service and provides an
	 * indication of the functionality that is managed. This functionality is
	 * described in more detail in the object's Description property.
	 * 
	 * @return String
	 */

	public String getName() {
		// No implementation.
		return null;

	}

	/*
	 * The name of the primary owner for the service, if one is defined. The
	 * primary owner is the initial support contact for the Service.
	 * 
	 * @return String
	 */

	public String getPrimaryOwnerName() {
		// No implementation.
		return null;

	}

	/*
	 * @param String
	 */
	public void setPrimaryOwnerName(String PrimaryOwnerName) {
		// No implementation.
	}

	/*
	 * A string that provides information on how the primary owner of the
	 * Service can be reached (e.g. phone number, email address, ...).
	 * 
	 * @return String
	 */

	public String getPrimaryOwnerContact() {
		// No implementation.
		return null;

	}

	/*
	 * @param String
	 */
	public void setPrimaryOwnerContact(String PrimaryOwnerContact) {
		// No implementation.
	}

	/*
	 * StartMode is a string value indicating whether the Service is
	 * automatically started by a System, Operating System, etc. or only started
	 * upon request. This property is deprecated in lieu of the EnabledDefault
	 * property inherited from EnabledLogicalElement, which addresses the same
	 * semantics. The change to a uint16 data type was discussed when CIM V2.0
	 * was defined. However, existing V1.0 implementations used the string
	 * property and did not want to modify their code. Therefore, StartMode was
	 * grandfathered into the Schema. Use of the Deprecated qualifier allows the
	 * maintenance of the existing property, but also permits an improved,
	 * clarified definition using EnabledDefault.
	 * 
	 * @return String
	 */

	public String getStartMode() {
		// No implementation.
		return null;

	}

	/*
	 * Started is a boolean indicating whether the Service has been started
	 * (TRUE), or stopped (FALSE).
	 * 
	 * @return boolean
	 */

	public boolean getStarted() {
		// No implementation.
		return false;
	}

	/*
	 * EnabledState is an integer enumeration that indicates the
	 * enabled/disabled states of an element. It can also indicate the
	 * transitions between these requested states. For example, shutting down
	 * (value = 4) and starting (value=10) are transient states between enabled
	 * and disabled. The following text briefly summarizes the various
	 * enabled/disabled states: Enabled (2) indicates that the element is/could
	 * be executing commands, will process any queued commands, and queues new
	 * requests. Disabled (3) indicates that the element will not execute
	 * commands and will drop any new requests. Shutting Down (4) indicates that
	 * the element is in the process of going to a Disabled state. Not
	 * Applicable (5) indicates the element doesn't support being
	 * enabled/disabled. Enabled but Offline (6) indicates that the element may
	 * be completing commands, and will drop any new requests. Test (7)
	 * indicates that the element is in a test state. Deferred (8) indicates
	 * that the element may be completing commands, but will queue any new
	 * requests. Quiesce (9) indicates that the element is enabled but in a
	 * restricted mode. The element's behavior is similar to the Enabled state,
	 * but it only processes a restricted set of commands. All other requests
	 * are queued. Starting (10) indicates that the element is in the process of
	 * going to an Enabled state. New requests are queued.
	 * 
	 * @return short
	 */

	public short getEnabledState() {
		// No implementation.
		return ENABLEDSTATE;
	}

	/*
	 * A string describing the element's enabled/disabled state when the
	 * EnabledState property is set to 1 ("Other"). This property MUST be set to
	 * NULL when EnabledState is any value other than 1.
	 * 
	 * @return String
	 */

	public String getOtherEnabledState() {
		// No implementation.
		return null;

	}

	/*
	 * RequestedState is an integer enumeration indicating the last requested or
	 * desired state for the element. The actual state of the element is
	 * represented by EnabledState. This property is provided to compare the
	 * last requested and current enabled/disabled states. Note that when
	 * EnabledState is set to 5 ("Not Applicable"), then this property has no
	 * meaning. By default, the element's RequestedState is 5 ("No Change").
	 * Refer to the EnabledState's property Description for explanations of the
	 * values in the RequestedState enumeration.
	 * 
	 * It should be noted that there are two new values in RequestedState that
	 * build on the statuses of EnabledState. These are "Reboot" (10) and
	 * "Reset" (11). The former, Reboot, refers to doing a "Shut Down" and then
	 * moving to an "Enabled" state. The latter, Reset, indicates that the
	 * element is first "Disabled" and then "Enabled". The distinction between
	 * requesting "Shut Down" and "Disabled" should also be noted. The former,
	 * Shut Down, requests an orderly transition to the Disabled state, and MAY
	 * involve removing power, to completely erase any existing state. The
	 * latter, the Disabled state, requests an immediate disabling of the
	 * element, such that it will not execute or accept any commands or
	 * processing requests.
	 * 
	 * This property is set as the result of a method invocation (such as Start
	 * or StopService on CIM_Service), or may be overridden and defined as
	 * WRITEable in a subclass. The method approach is considered superior to a
	 * WRITEable property, since it allows an explicit invocation of the
	 * operation and the return of a result code.
	 * 
	 * @return short
	 */

	public short getRequestedState() {
		// No implementation.
		return REQUESTEDSTATE;
	}

	/*
	 * An enumerated value indicating an administrator's default/startup
	 * configuration for an element's Enabled State. By default, the element is
	 * "Enabled" (value=2).
	 * 
	 * @return short
	 */

	public short getEnabledDefault() {
		// No implementation.
		return ENABLEDDEFAULT;
	}

	/*
	 * @param short
	 */
	public void setEnabledDefault(short EnabledDefault) {
		// No implementation.
	}

	/*
	 * The date/time when the element's EnabledState last changed. If the state
	 * of the element has not changed and this property is populated, then it
	 * MUST be set to a 0 interval value. If a state change was requested, but
	 * rejected or not yet processed, the property MUST NOT be updated.
	 * 
	 * @return Date
	 */

	public Date getTimeOfLastStateChange() {
		// No implementation.
		return null;

	}

	/*
	 * A datetime value indicating when the object was installed. A lack of a
	 * value does not indicate that the object is not installed.
	 * 
	 * @return Date
	 */

	public Date getInstallDate() {
		// No implementation.
		return null;

	}

	/*
	 * A string indicating the current status of the object. Various operational
	 * and non-operational statuses are defined. This property is deprecated in
	 * lieu of OperationalStatus, which includes the same semantics in its
	 * enumeration. This change is made for 3 reasons: 1) Status is more
	 * correctly defined as an array. This overcomes the limitation of
	 * describing status via a single value, when it is really a multi-valued
	 * property (for example, an element may be OK AND Stopped. 2) A MaxLen of
	 * 10 is too restrictive and leads to unclear enumerated values. And, 3) The
	 * change to a uint16 data type was discussed when CIM V2.0 was defined.
	 * However, existing V1.0 implementations used the string property and did
	 * not want to modify their code. Therefore, Status was grandfathered into
	 * the Schema. Use of the Deprecated qualifier allows the maintenance of the
	 * existing property, but also permits an improved definition using
	 * OperationalStatus.
	 * 
	 * @return String
	 */

	public String getStatus() {
		// No implementation.
		return null;

	}

	/*
	 * Indicates the current status(es) of the element. Various health and
	 * operational statuses are defined. Many of the enumeration's values are
	 * self- explanatory. However, a few are not and are described in more
	 * detail. "Stressed" indicates that the element is functioning, but needs
	 * attention. Examples of "Stressed" states are overload, overheated, etc.
	 * "Predictive Failure" indicates that an element is functioning nominally
	 * but predicting a failure in the near future. "In Service" describes an
	 * element being configured, maintained, cleaned, or otherwise administered.
	 * "No Contact" indicates that the monitoring system has knowledge of this
	 * element, but has never been able to establish communications with it.
	 * "Lost Communication" indicates that the ManagedSystem Element is known to
	 * exist and has been contacted successfully in the past, but is currently
	 * unreachable. "Stopped" and "Aborted" are similar, although the former
	 * implies a clean and orderly stop, while the latter implies an abrupt stop
	 * where the element's state and configuration may need to be updated.
	 * "Dormant" indicates that the element is inactive or quiesced.
	 * "Supporting Entity in Error" describes that this element may be "OK" but
	 * that another element, on which it is dependent, is in error. An example
	 * is a network service or endpoint that cannot function due to lower layer
	 * networking problems. "Completed" indicates the element has completed its
	 * operation. This value should be combined with either OK, Error, or
	 * Degraded so that a client can till if the complete operation passed
	 * (Completed with OK), and failure (Completed with Error). Completed with
	 * Degraded would imply the operation finished, but did not complete OK or
	 * report an error. "Power Mode" indicates the element has additional power
	 * model information contained in the Associated PowerManagementService
	 * association. OperationalStatus replaces the Status property on
	 * ManagedSystemElement to provide a consistent approach to enumerations, to
	 * address implementation needs for an array property, and to provide a
	 * migration path from today's environment to the future. This change was
	 * not made earlier since it required the DEPRECATED qualifier. Due to the
	 * widespread use of the existing Status property in management
	 * applications, it is strongly RECOMMENDED that providers/instrumentation
	 * provide BOTH the Status and OperationalStatus properties. Further, the
	 * first value of OperationalStatus SHOULD contain the primary status for
	 * the element. When instrumented, Status (since it is single-valued) SHOULD
	 * also provide the primary status of the element.
	 * 
	 * @return short
	 */

	public short[] getOperationalStatus() {
		// No implementation.
		return null;
	}

	/*
	 * Strings describing the various OperationalStatus array values. For
	 * example, if "Stopping" is the value assigned to OperationalStatus, then
	 * this property may contain an explanation as to why an object is being
	 * stopped. Note that entries in this array are correlated with those at the
	 * same array index in OperationalStatus.
	 * 
	 * @return String
	 */

	public String[] getStatusDescriptions() {
		// No implementation.
		return null;

	}

	/*
	 * The Caption property is a short textual description (one- line string) of
	 * the object.
	 * 
	 * @return String
	 */

	public String getCaption() {
		// No implementation.
		return null;

	}

	/*
	 * The Description property provides a textual description of the object.
	 * 
	 * @return String
	 */

	public String getDescription() {
		// No implementation.
		return null;

	}

	/*
	 * A user-friendly name for the object. This property allows each instance
	 * to define a user-friendly name IN ADDITION TO its key properties/identity
	 * data, and description information. Note that ManagedSystemElement's Name
	 * property is also defined as a user-friendly name. But, it is often
	 * subclassed to be a Key. It is not reasonable that the same property can
	 * convey both identity and a user friendly name, without inconsistencies.
	 * Where Name exists and is not a Key (such as for instances of
	 * LogicalDevice), the same information MAY be present in both the Name and
	 * ElementName properties.
	 * 
	 * @return String
	 */

	public String getElementName() {
		// No implementation.
		return null;

	}

	public com.sap.engine.services.ts.mbeans.SAP_ITSAMExtendedPendingTransactionData retrievePendingTransactionInfo(
			String systemId, int nodeId, long tmStartupTime, long transactionSeqNumber) {
		
		try{
			PendingTXData pendingTXData = PTLProcessor.getPendingTxInfo(systemId.getBytes("US-ASCII"), nodeId, tmStartupTime, transactionSeqNumber);
			if(pendingTXData != null){
				return pendingTXData.getITSAMExtendedPendingTxData();
			} else {
				SAP_ITSAMExtendedPendingTransactionData result = new SAP_ITSAMExtendedPendingTransactionData();
				SAP_ITSAMJ2eeActionStatus actionStatus = new SAP_ITSAMJ2eeActionStatus();
				actionStatus.setCode(SAP_ITSAMJ2eeActionStatus.WARNING_CODE);
				actionStatus.setMessageId(ExceptionConstants.Pending_Transaction_is_already_completed);
				actionStatus.setMessageParameters(new String[]{Long.toString(transactionSeqNumber)});
				SimpleLogger.trace(Severity.WARNING, LOCATION,LocalizableTextFormatter.formatString(
						TSResourceAccessor.getResourceAccessor(), ExceptionConstants.Pending_Transaction_is_already_completed, new String[]{Long.toString(transactionSeqNumber)}));
				result.setActionStatus(actionStatus);
				return result;
			}
		} catch (Exception e){
			SAP_ITSAMExtendedPendingTransactionData result = new SAP_ITSAMExtendedPendingTransactionData();
			SAP_ITSAMJ2eeActionStatus actionStatus = new SAP_ITSAMJ2eeActionStatus();
			actionStatus.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			actionStatus.setMessageId(ExceptionConstants.Unexpected_Exception_during_RetrievePendingTxInfo);
			actionStatus.setMessageParameters(new String[]{Long.toString(transactionSeqNumber), e.toString()});
			String stackTrace = Util.getStackTrace(e);
			actionStatus.setStackTrace(stackTrace);
			try {
				SimpleLogger.traceThrowable(Severity.ERROR, LOCATION,LocalizableTextFormatter.formatString(
						TSResourceAccessor.getResourceAccessor(), ExceptionConstants.Unexpected_Exception_during_RetrievePendingTxInfo, new String[]{Long.toString(transactionSeqNumber), e.toString()}), e);
			} catch (LocalizationException e1) {
				SimpleLogger.traceThrowable(Severity.ERROR, LOCATION,
						ExceptionConstants.Unexpected_Exception_during_RetrievePendingTxInfo + stackTrace, e1);			}
			result.setActionStatus(actionStatus);
			return result;	
		}
		
	}

	public com.sap.engine.services.ts.mbeans.SAP_ITSAMJ2eeActionStatus abandonTransaction(
			String systemId, int nodeId, long tmStartupTime,
			long transactionSeqNumber) {

		try{
			if(PTLProcessor.abandonTransaction(systemId.getBytes("US-ASCII"), nodeId, tmStartupTime, transactionSeqNumber)){
				SAP_ITSAMJ2eeActionStatus actionStatus = new SAP_ITSAMJ2eeActionStatus();
				actionStatus.setCode(SAP_ITSAMJ2eeActionStatus.OK_CODE);
				return actionStatus;
			} else {
				SAP_ITSAMJ2eeActionStatus actionStatus = new SAP_ITSAMJ2eeActionStatus();
				actionStatus.setCode(SAP_ITSAMJ2eeActionStatus.WARNING_CODE);
				actionStatus.setMessageId(ExceptionConstants.Pending_Transaction_is_already_completed);
				actionStatus.setMessageParameters(new String[]{Long.toString(transactionSeqNumber)});
				SimpleLogger.trace(Severity.WARNING, LOCATION,LocalizableTextFormatter.formatString(
						TSResourceAccessor.getResourceAccessor(), ExceptionConstants.Pending_Transaction_is_already_completed, new String[]{Long.toString(transactionSeqNumber)}));
				return actionStatus;
			}
		} catch (Exception e){
			SAP_ITSAMJ2eeActionStatus actionStatus = new SAP_ITSAMJ2eeActionStatus();
			actionStatus.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			actionStatus.setMessageId(ExceptionConstants.Unexpected_Exception_during_AbandonTransaction);
			actionStatus.setMessageParameters(new String[]{Long.toString(transactionSeqNumber), e.toString()});
			String stackTrace = Util.getStackTrace(e);
			actionStatus.setStackTrace(stackTrace);
			try {
				SimpleLogger.traceThrowable(Severity.ERROR, LOCATION,LocalizableTextFormatter.formatString(
						TSResourceAccessor.getResourceAccessor(), ExceptionConstants.Unexpected_Exception_during_AbandonTransaction, new String[]{Long.toString(transactionSeqNumber), e.toString()}), e);
			} catch (LocalizationException e1) {
				SimpleLogger.traceThrowable(Severity.ERROR, LOCATION,
						ExceptionConstants.Unexpected_Exception_during_AbandonTransaction + stackTrace, e1);	
			}
			return actionStatus;			
		}		
	}

	public com.sap.engine.services.ts.mbeans.SAP_ITSAMJ2eeActionStatus forgetTransaction(
			String systemId, int nodeId, long tmStartupTime,
			long transactionSeqNumber) {

		try{
			if(PTLProcessor.forgetTransaction(systemId.getBytes("US-ASCII"), nodeId, tmStartupTime, transactionSeqNumber)){
				SAP_ITSAMJ2eeActionStatus actionStatus = new SAP_ITSAMJ2eeActionStatus();
				actionStatus.setCode(SAP_ITSAMJ2eeActionStatus.OK_CODE);
				return actionStatus;
			} else {
				SAP_ITSAMJ2eeActionStatus actionStatus = new SAP_ITSAMJ2eeActionStatus();
				actionStatus.setCode(SAP_ITSAMJ2eeActionStatus.WARNING_CODE);
				actionStatus.setMessageId(ExceptionConstants.Pending_Transaction_is_already_completed);
				actionStatus.setMessageParameters(new String[]{Long.toString(transactionSeqNumber)});
				SimpleLogger.trace(Severity.WARNING, LOCATION,LocalizableTextFormatter.formatString(
						TSResourceAccessor.getResourceAccessor(), ExceptionConstants.Pending_Transaction_is_already_completed, new String[]{Long.toString(transactionSeqNumber)}));
				return actionStatus;
			}
		} catch (Exception e){
			SAP_ITSAMJ2eeActionStatus actionStatus = new SAP_ITSAMJ2eeActionStatus();
			actionStatus.setCode(SAP_ITSAMJ2eeActionStatus.ERROR_CODE);
			actionStatus.setMessageId(ExceptionConstants.Unexpected_Exception_during_ForgetTransaction);
			actionStatus.setMessageParameters(new String[]{Long.toString(transactionSeqNumber), e.toString()});
			String stackTrace = Util.getStackTrace(e);
			actionStatus.setStackTrace(stackTrace);
			try {
				SimpleLogger.traceThrowable(Severity.ERROR, LOCATION, LocalizableTextFormatter.formatString(
						TSResourceAccessor.getResourceAccessor(), ExceptionConstants.Unexpected_Exception_during_ForgetTransaction, new String[]{Long.toString(transactionSeqNumber), e.toString()}), e);
			} catch (LocalizationException e1) {
				SimpleLogger.traceThrowable(Severity.ERROR, LOCATION,
						ExceptionConstants.Unexpected_Exception_during_ForgetTransaction + stackTrace, e1);	
			}
			return actionStatus;			
		}		

	}

	public void clearTransactionsStatistics() {
		try{
			TransactionStatistics.clearTransactionStatistics();
		} catch (Exception e){
			try {
				SimpleLogger.traceThrowable(Severity.INFO, LOCATION, LocalizableTextFormatter.formatString(
						TSResourceAccessor.getResourceAccessor(), ExceptionConstants.Unexpected_Exception_during_ClearTransactionStatistics, new String[]{}), e);
			} catch (LocalizationException e1) {
				SimpleLogger.traceThrowable(Severity.ERROR, LOCATION,
						ExceptionConstants.Unexpected_Exception_during_ClearTransactionStatistics + Util.getStackTrace(e), e1);	
			}			
		}
	}

	public void StartService() {
		// No implementation.
	}

	public void StopService() {
		// No implementation.
	}

	public ObjectName RequestStateChange(short RequestedState, Date TimeoutPeriod) {
		// No implementation.
		return null;
	}

}
